import{_ as o,c as i,a as e,o as s}from"./app-D6s_7T7O.js";const c="/doc2show/img/22/1.png",a="/doc2show/img/22/2.png",l="/doc2show/img/22/3.png",t="/doc2show/img/22/4.png",n="/doc2show/img/22/5.png",r="/doc2show/img/22/6.png",m="/doc2show/img/22/7.png",d="/doc2show/img/22/8.png",h="/doc2show/img/22/9.png",g="/doc2show/img/22/10.png",_="/doc2show/img/22/11.png",k="/doc2show/img/22/12.png",u="/doc2show/img/22/13.png",x="/doc2show/img/22/14.png",w="/doc2show/img/22/15.png",f="/doc2show/img/22/16.png",b="/doc2show/img/22/17.png",v="/doc2show/img/22/18.png",M="/doc2show/img/22/19.png",A="/doc2show/img/22/20.png",P="/doc2show/img/22/21.png",S="/doc2show/img/22/22.png",I="/doc2show/img/22/23.png",T="/doc2show/img/22/24.png",C="/doc2show/img/22/25.png",E="/doc2show/img/22/26.png",y="/doc2show/img/22/27.png",D="/doc2show/img/22/28.png",F={};function J(N,p){return s(),i("div",null,p[0]||(p[0]=[e('<p>大家好，我是村长！</p><p>前面我们学习了数据库管理和设计相关操作，并且添加了一些初始数据，接下来就是编写接口获取数据了。</p><p>但是在实际开发中是不会直接开撸代码的，通常大家需要先讨论并设计出接口文档，然后前后端才按照文档分头行动。</p><p>这个流程是有标准可循的，比如早先的 Swagger(Open API)，会按照规范先设计接口，定好接口用例，编写模拟数据规则供前端开发使用，开发完接口再调用接口用例调试接口，这个过程很多步骤需要手动完成，且要在不同工具间切换，比较麻烦。</p><p>我们计划在项目中将使用 Apifox 统一完成这些任务以提高效率，本节内容如下：</p><ul><li>接口设计流程；</li><li>安装 Apifox；</li><li>接口设计；</li><li>接口用例和调试；</li><li>接口 mock；</li><li>代码生成。</li></ul><h2 id="接口设计流程" tabindex="-1"><a class="header-anchor" href="#接口设计流程"><span>接口设计流程</span></a></h2><p>设计接口基本上遵循下面流程：</p><ol><li><p>前端（或后端）在 Apifox 上定好<code>接口文档</code>初稿。</p></li><li><p>前后端一起评审、完善<code>接口文档</code>，定好<code>接口用例</code>。</p></li><li><p>前端使用系统根据接口文档自动生成的 <code>Mock 数据</code>进入开发，无需手写 mock 规则。</p></li><li><p>后端使用<code>接口用例</code> 调试开发中接口，只要所有接口用例调试通过，接口就开发完成了。如开发过中接口有变化，调试的时候就自动更新了文档，零成本保障了接口维护的及时性。</p></li><li><p>后端每次调试完一个功能就保存为一个<code>接口用例</code>。</p></li><li><p>测试人员直接使用<code>接口用例</code>测试接口。</p></li><li><p>所有接口开发完成后，测试人员（也可以是后端）使用<code>集合测试</code>功能进行多接口集成测试，完整测试整个接口调用流程。</p></li><li><p>前后端都开发完，前端从<code>Mock 数据</code>切换到<code>正式数据</code>，联调通常都会非常顺利，因为前后端双方都完全遵守了接口定义的规范。</p></li></ol><h2 id="安装-apifox" tabindex="-1"><a class="header-anchor" href="#安装-apifox"><span>安装 Apifox</span></a></h2><p>Apifox 有两种使用方式：</p><ul><li>Web版：<a href="https://www.apifox.cn/web" target="_blank" rel="noopener noreferrer">https://www.apifox.cn/web</a></li><li>客户端：<a href="https://www.apifox.cn/" target="_blank" rel="noopener noreferrer">官网下载</a></li></ul><p>Web 端大部分功能相同，缺少本地 Mock 能力，因此我们将使用客户端给大家做演示，大家首先下载系统对应客户端并安装。启动后需要扫码登录，进入之后效果如下：</p><p><img src="'+c+'" alt=""></p><h3 id="创建项目" tabindex="-1"><a class="header-anchor" href="#创建项目"><span>创建项目</span></a></h3><p>首先点击“新建项目”创建项目：</p><p><img src="'+a+'" alt=""></p><p>点击创建好的项目进入主视图：</p><p><img src="'+l+'" alt=""></p><h2 id="接口设计" tabindex="-1"><a class="header-anchor" href="#接口设计"><span>接口设计</span></a></h2><p>接下来点击“新建接口”准备设计我们的第一个接口，首先填入接口路径、名称等基本信息。</p><h3 id="创建接口" tabindex="-1"><a class="header-anchor" href="#创建接口"><span>创建接口</span></a></h3><p>我们这里创建 /course 接口，用于获取课程列表：</p><p><img src="'+t+'" alt=""></p><p>下面定义参数，这里传递查询参数 page 和 size 用于分页查询：</p><p><img src="'+n+'" alt=""></p><p>下面定义返回响应，一般是成功状态和若干错误状态，这里定义 200 状态下的响应。</p><p>点击内容格式下面的 object 可以选择响应的数据类型，我们需要一个数组，因此选择 array。</p><p><img src="'+r+'" alt=""></p><p>然后设置数组项，点击 ITEMS 后面的 string，设置数组项格式：</p><p><img src="'+m+'" alt=""></p><h3 id="创建数据模型" tabindex="-1"><a class="header-anchor" href="#创建数据模型"><span>创建数据模型</span></a></h3><p>这里需要一个 course 对象，可以创建一个数据模型：</p><p><img src="'+d+'" alt=""></p><p><img src="'+h+'" alt=""></p><p>下面在响应数据中选用刚创建的 Course 模型：</p><p><img src="'+g+'" alt=""></p><p><img src="'+_+'" alt=""></p><p>这就完成了接口设计！</p><h2 id="接口用例和调试" tabindex="-1"><a class="header-anchor" href="#接口用例和调试"><span>接口用例和调试</span></a></h2><p>接口一般都会有响应示例给开发者参考，例如成功响应和失败响应的数据结构。</p><h3 id="添加响应示例" tabindex="-1"><a class="header-anchor" href="#添加响应示例"><span>添加响应示例</span></a></h3><p>下面设置“响应示例”，点击“添加示例”：</p><p><img src="'+k+'" alt=""></p><p>选择“成功示例”，然后点击“自动生成”：这将会为我们的接口文档生成响应示例：</p><p><img src="'+u+'" alt=""></p><p>点击“确定”之后别忘了点击“保存”。</p><h3 id="调试接口" tabindex="-1"><a class="header-anchor" href="#调试接口"><span>调试接口</span></a></h3><p>接下来我们调试接口，点击“运行”按钮，或进入“运行”页签：</p><p><img src="'+x+'" alt=""></p><p>点击右上角环境选择，选择“本地Mock”：</p><p><img src="'+w+'" alt=""></p><p>然后点击“发送”就可以调试接口了！</p><p>效果如下：请求成功了！</p><p><img src="'+f+'" alt=""></p><h3 id="添加接口用例" tabindex="-1"><a class="header-anchor" href="#添加接口用例"><span>添加接口用例</span></a></h3><p>可以看到我们请求接口的时候会有各种各样的用法：传参、不传参、设置请求头、cookie，甚至传递错误的数据等等。 <strong>每种用法都是一个接口用例。</strong> 前面演示中如果点击“保存为用例”，将会快速创建接口用例。</p><p><img src="'+b+'" alt=""></p><p>点“确定”，效果如下：这样可以随时再次调试接口了！</p><p><img src="'+v+'" alt=""></p><h2 id="接口-mock" tabindex="-1"><a class="header-anchor" href="#接口-mock"><span>接口 mock</span></a></h2><p>前面并没有开发任何接口，请求却可以成功，是因为有本地 mock 服务。</p><p>接口 mock 可以让前端在没有开发接口的情况下开始开发工作，保证了开发效率。我们可以点击文档 - 本地 Mock，复制url：</p><p><img src="'+M+'" alt=""></p><p>就可以请求该接口进行前端开发了！</p><p><img src="'+A+'" alt=""></p><h3 id="手动设置-mock-规则" tabindex="-1"><a class="header-anchor" href="#手动设置-mock-规则"><span>手动设置 mock 规则</span></a></h3><p>Mock 数据是根据“返回响应”定义的结果对象自动生成的，这就可能造成生成数据不是期望结果的情况。例如前面案例中生成的 cover 字段的值就不是我们期待的图片链接：</p><p><img src="'+P+'" alt=""></p><p>此时，可以手动设置 mock 规则，从而达到期望：这里我设置了 Course 模型 cover 字段的 mock 规则为 <code>@image</code>：</p><p><img src="'+S+'" alt=""></p><p>现在，删掉之前的响应示例，重新生成结果如下：可以看到 cover 达到了期望！</p><p><img src="'+I+'" alt=""></p><h3 id="高级-mock" tabindex="-1"><a class="header-anchor" href="#高级-mock"><span>高级 mock</span></a></h3><p>当然 mock 还有更强大的控制方式，例如“mock 期望”，可以根据不同条件获得不同的 mock 结果。</p><p>点击“高级 mock”页签，点击“新建期望”：通过设置多个期望，可以针对不同参数条件生成对应结果：</p><p><img src="'+T+'" alt=""></p><p>甚至还能编写 JS 脚本来控制最终生成结果：</p><p><img src="'+C+'" alt=""></p><h2 id="代码生成" tabindex="-1"><a class="header-anchor" href="#代码生成"><span>代码生成</span></a></h2><p>接口设置好了之后，对于开发者来说，“代码生成”是一个比较有用的功能，例如我想生成一段请求课程列表接口的 ts 代码，就可以点击文档 - 生成代码 - 生成业务代码：</p><p><img src="'+E+'" alt=""></p><p>设置生成范围等，代码风格之后，点击“生成代码”即可：</p><p><img src="'+y+'" alt=""></p><blockquote><p>生成代码需要安装插件和 Java 环境</p></blockquote><p>生成代码片段如下:</p><p><img src="'+D+'" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，关于接口设计就跟小伙伴们介绍到这里了。我们总结一下，要设计一个接口，我们需要：</p><ol><li>创建接口和数据模型；</li><li>定义请求参数；</li><li>添加响应示例；</li><li>调试接口；</li><li>调整 mock 规则等细节。</li></ol><p>应该说涵盖了比较重要的部分，不过还是有一些细节的东西需要大家额外花时间探究一下。</p><h2 id="下次预告" tabindex="-1"><a class="header-anchor" href="#下次预告"><span>下次预告</span></a></h2><p>现在可以说万事俱备只欠东风，下一步我们就可以开始真正的接口开发工作了。</p><p>下节课我们会使用 Prisma 这样的 node.js ORM 框架编写接口，这样我们直接编写 node 代码即可请求数据库，而不用编写繁杂的 SQL 语句，可以在开发效率和可维护性上大幅提升。</p>',94)]))}const j=o(F,[["render",J],["__file","index.html.vue"]]),q=JSON.parse(`{"path":"/nuxt3/pi8nh81y/","title":"22-基于 APIFox 的接口设计最佳实践","lang":"zh-CN","frontmatter":{"title":"22-基于 APIFox 的接口设计最佳实践","author":"Your name","createTime":"2024/07/29 16:11:51","permalink":"/nuxt3/pi8nh81y/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"接口设计流程","slug":"接口设计流程","link":"#接口设计流程","children":[]},{"level":2,"title":"安装 Apifox","slug":"安装-apifox","link":"#安装-apifox","children":[{"level":3,"title":"创建项目","slug":"创建项目","link":"#创建项目","children":[]}]},{"level":2,"title":"接口设计","slug":"接口设计","link":"#接口设计","children":[{"level":3,"title":"创建接口","slug":"创建接口","link":"#创建接口","children":[]},{"level":3,"title":"创建数据模型","slug":"创建数据模型","link":"#创建数据模型","children":[]}]},{"level":2,"title":"接口用例和调试","slug":"接口用例和调试","link":"#接口用例和调试","children":[{"level":3,"title":"添加响应示例","slug":"添加响应示例","link":"#添加响应示例","children":[]},{"level":3,"title":"调试接口","slug":"调试接口","link":"#调试接口","children":[]},{"level":3,"title":"添加接口用例","slug":"添加接口用例","link":"#添加接口用例","children":[]}]},{"level":2,"title":"接口 mock","slug":"接口-mock","link":"#接口-mock","children":[{"level":3,"title":"手动设置 mock 规则","slug":"手动设置-mock-规则","link":"#手动设置-mock-规则","children":[]},{"level":3,"title":"高级 mock","slug":"高级-mock","link":"#高级-mock","children":[]}]},{"level":2,"title":"代码生成","slug":"代码生成","link":"#代码生成","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"下次预告","slug":"下次预告","link":"#下次预告","children":[]}],"readingTime":{"minutes":6.24,"words":1871},"git":{"createdTime":1722241276000,"updatedTime":1728783252000,"contributors":[{"name":"DengChang","email":"85365","commits":1},{"name":"xxdl","email":"xxdl@xxdl.top","commits":1}]},"filePathRelative":"notes/nuxt3/22-基于 APIFox 的接口设计最佳实践.md"}`);export{j as comp,q as data};
